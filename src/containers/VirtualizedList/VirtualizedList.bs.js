// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Belt_SortArray = require("bs-platform/lib/js/belt_SortArray.js");
var Belt_HashMapInt = require("bs-platform/lib/js/belt_HashMapInt.js");
var List$ReactHooksTemplate = require("./List.bs.js");

function add(a, b) {
  return a + b | 0;
}

function recsHeight(data, identity, rectangles) {
  return Belt_Option.mapWithDefault(Belt_Option.flatMap(Belt_Option.map(Belt_Array.get(data, data.length - 1 | 0), identity), (function (id) {
                    return Belt_HashMapInt.get(rectangles, id);
                  })), 0, (function (item) {
                return item[/* height */1] + item[/* top */0] | 0;
              }));
}

function heightDelta(data, identity, rectangles, previousRectangles) {
  return recsHeight(data, identity, previousRectangles) - recsHeight(data, identity, rectangles) | 0;
}

function calculateHeight(elementRef, heightMap, id, margin) {
  Belt_Option.map((elementRef == null) ? undefined : Caml_option.some(elementRef), (function (x) {
          return Belt_HashMapInt.set(heightMap.current, id, margin + x.getBoundingClientRect().height | 0);
        }));
  return /* () */0;
}

function scheduler(callback, scheduler$1) {
  var ticking = /* record */[/* contents */false];
  var update = function (e) {
    ticking[0] = false;
    Curry._1(callback, e);
    return /* () */0;
  };
  return (function (e) {
      if (!ticking[0]) {
        Curry._1(scheduler$1, update);
      }
      ticking[0] = true;
      return /* () */0;
    });
}

function scrollTop(prim) {
  return prim.scrollTop;
}

function log(prim) {
  console.log(prim);
  return /* () */0;
}

function throttle(fn) {
  var inThrottle = /* record */[/* contents */false];
  return (function (e) {
      if (inThrottle[0]) {
        return 0;
      } else {
        inThrottle[0] = true;
        Curry._1(fn, e);
        setTimeout((function (param) {
                inThrottle[0] = false;
                return /* () */0;
              }), 100);
        return /* () */0;
      }
    });
}

function sortByKey(a, b) {
  var id_b = b[0];
  var id_a = a[0];
  var match = Caml_obj.caml_greaterthan(id_a, id_b);
  if (match) {
    return 1;
  } else if (id_a === id_b) {
    return 0;
  } else {
    return -1;
  }
}

var defaultPositionValue_001 = /* heightMap */Belt_HashMapInt.make(100);

var defaultPositionValue = /* record */[
  /* scrollPosition */15000,
  defaultPositionValue_001
];

function isBetween(target, beginning, endValue) {
  if (Caml_obj.caml_greaterequal(target, beginning)) {
    return Caml_obj.caml_lessequal(target, endValue);
  } else {
    return false;
  }
}

function doesIntersectWith(a, b) {
  if (isBetween(a[/* top */0], b[/* top */0], b[/* top */0] + b[/* height */1] | 0)) {
    return true;
  } else {
    return isBetween(b[/* top */0], a[/* top */0], a[/* top */0] + a[/* height */1] | 0);
  }
}

function createNewRecs(heightMap, identity, defaultHeight, data) {
  var recs = Belt_HashMapInt.make(100);
  var currentHeight = /* record */[/* contents */0];
  var convertToSortedArray = function (heightMap) {
    var map = heightMap.current;
    return Belt_SortArray.stableSortBy(Belt_Array.map(Belt_Array.map(data, (function (item) {
                          var id = Curry._1(identity, item);
                          return /* tuple */[
                                  id,
                                  defaultHeight
                                ];
                        })), (function (item) {
                      var id = item[0];
                      return Belt_Option.mapWithDefault(Belt_HashMapInt.get(map, id), item, (function (measuredHeight) {
                                    return /* tuple */[
                                            id,
                                            measuredHeight
                                          ];
                                  }));
                    })), sortByKey);
  };
  Belt_Array.forEach(convertToSortedArray(heightMap), (function (item) {
          var height = item[1];
          Belt_HashMapInt.set(recs, item[0], /* record */[
                /* top */currentHeight[0],
                /* height */height
              ]);
          currentHeight[0] = currentHeight[0] + height | 0;
          return /* () */0;
        }));
  return recs;
}

function VirtualizedList(Props) {
  var match = Props.refreshingComponent;
  var refreshingComponent = match !== undefined ? Caml_option.valFromOption(match) : null;
  var refreshing = Props.refreshing;
  var match$1 = Props.margin;
  var margin = match$1 !== undefined ? match$1 : 0;
  var match$2 = Props.bufferCount;
  var bufferCount = match$2 !== undefined ? match$2 : 5;
  var defaultPosition = Props.defaultPosition;
  var defaultHeightMap = Props.defaultHeightMap;
  var onDestroy = Props.onDestroy;
  var match$3 = Props.defaultHeight;
  var defaultHeight = match$3 !== undefined ? match$3 : 200;
  var data = Props.data;
  var identity = Props.identity;
  var viewPortRef = Props.viewPortRef;
  var renderItem = Props.renderItem;
  var match$4 = React.useState((function () {
          return /* record */[
                  /* startIndex */-1,
                  /* endIndex */10
                ];
        }));
  var setIndex = match$4[1];
  var match$5 = match$4[0];
  var endIndex = match$5[/* endIndex */1];
  var startIndex = match$5[/* startIndex */0];
  var match$6 = React.useState((function () {
          return 0;
        }));
  var setCorrection = match$6[1];
  var refMap = React.useRef(Belt_HashMapInt.make(100));
  var heightMap = React.useRef(Belt_Option.mapWithDefault(defaultHeightMap, Belt_HashMapInt.make(100), (function (x) {
              return x;
            })));
  var recMap = React.useRef(Belt_HashMapInt.make(100));
  var viewPortRec = React.useRef(/* record */[
        /* top */0,
        /* height */0
      ]);
  var prevViewPortRec = React.useRef(/* record */[
        /* top */0,
        /* height */0
      ]);
  var previousSnapshot = React.useRef(/* record */[
        /* startIndex */0,
        /* endIndex */0
      ]);
  var element = Belt_Option.map(Caml_option.nullable_to_opt(viewPortRef.current), (function (prim) {
          return prim;
        }));
  var rawHandler = function (element) {
    if (element !== undefined) {
      var element$1 = Caml_option.valFromOption(element);
      var viewPortRectangle = viewPortRec.current;
      var startItem = Belt_Array.reduce(Belt_Array.map(data, (function (rawData) {
                  return Belt_Option.mapWithDefault(Belt_HashMapInt.get(recMap.current, Curry._1(identity, rawData)), /* tuple */[
                              Curry._1(identity, rawData),
                              /* record */[
                                /* top */0,
                                /* height */0
                              ]
                            ], (function (rectangle) {
                                return /* tuple */[
                                        Curry._1(identity, rawData),
                                        rectangle
                                      ];
                              }));
                })), /* tuple */[
            0,
            /* record */[
              /* top */0,
              /* height */0
            ]
          ], (function (param, item) {
              var sumRect = param[1];
              var match = (sumRect[/* top */0] + sumRect[/* height */1] | 0) > viewPortRectangle[/* top */0];
              if (match) {
                return /* tuple */[
                        param[0],
                        sumRect
                      ];
              } else {
                return item;
              }
            }));
      var endItem = Belt_Array.reduce(Belt_Array.map(data, (function (rawData) {
                  return Belt_Option.mapWithDefault(Belt_HashMapInt.get(recMap.current, Curry._1(identity, rawData)), /* tuple */[
                              Curry._1(identity, rawData),
                              /* record */[
                                /* top */0,
                                /* height */0
                              ]
                            ], (function (rectangle) {
                                return /* tuple */[
                                        Curry._1(identity, rawData),
                                        rectangle
                                      ];
                              }));
                })), /* tuple */[
            0,
            /* record */[
              /* top */0,
              /* height */0
            ]
          ], (function (param, item) {
              var sumRect = param[1];
              var match = (viewPortRectangle[/* top */0] + viewPortRectangle[/* height */1] | 0) <= sumRect[/* top */0];
              if (match) {
                return /* tuple */[
                        param[0],
                        sumRect
                      ];
              } else {
                return item;
              }
            }));
      Curry._1(setIndex, (function (_prev) {
              var init = previousSnapshot.current;
              previousSnapshot.current = /* record */[
                /* startIndex */_prev[/* startIndex */0],
                /* endIndex */init[/* endIndex */1]
              ];
              var init$1 = previousSnapshot.current;
              previousSnapshot.current = /* record */[
                /* startIndex */init$1[/* startIndex */0],
                /* endIndex */_prev[/* endIndex */1]
              ];
              prevViewPortRec.current = viewPortRec.current;
              viewPortRec.current = /* record */[
                /* top */element$1.scrollTop | 0,
                /* height */element$1.clientHeight
              ];
              var eid = endItem[0];
              var sid = startItem[0];
              var match = (sid - bufferCount | 0) < 1;
              var match$1 = (eid + bufferCount | 0) > data.length;
              return /* record */[
                      /* startIndex */match ? 1 : sid - bufferCount | 0,
                      /* endIndex */match$1 ? data.length : eid + bufferCount | 0
                    ];
            }));
    }
    Curry._1(setCorrection, (function (x) {
            return x + 1 | 0;
          }));
    return /* () */0;
  };
  var handleScroll = scheduler(throttle((function (_e) {
              if (element !== undefined) {
                var element$1 = Caml_option.valFromOption(element);
                var viewPortRectangle = viewPortRec.current;
                var startItem = Belt_Array.reduce(Belt_Array.map(data, (function (rawData) {
                            return Belt_Option.mapWithDefault(Belt_HashMapInt.get(recMap.current, Curry._1(identity, rawData)), /* tuple */[
                                        Curry._1(identity, rawData),
                                        /* record */[
                                          /* top */0,
                                          /* height */0
                                        ]
                                      ], (function (rectangle) {
                                          return /* tuple */[
                                                  Curry._1(identity, rawData),
                                                  rectangle
                                                ];
                                        }));
                          })), /* tuple */[
                      0,
                      /* record */[
                        /* top */0,
                        /* height */0
                      ]
                    ], (function (param, item) {
                        var sumRect = param[1];
                        var match = (sumRect[/* top */0] + sumRect[/* height */1] | 0) > viewPortRectangle[/* top */0];
                        if (match) {
                          return /* tuple */[
                                  param[0],
                                  sumRect
                                ];
                        } else {
                          return item;
                        }
                      }));
                var endItem = Belt_Array.reduce(Belt_Array.map(data, (function (rawData) {
                            return Belt_Option.mapWithDefault(Belt_HashMapInt.get(recMap.current, Curry._1(identity, rawData)), /* tuple */[
                                        Curry._1(identity, rawData),
                                        /* record */[
                                          /* top */0,
                                          /* height */0
                                        ]
                                      ], (function (rectangle) {
                                          return /* tuple */[
                                                  Curry._1(identity, rawData),
                                                  rectangle
                                                ];
                                        }));
                          })), /* tuple */[
                      0,
                      /* record */[
                        /* top */0,
                        /* height */0
                      ]
                    ], (function (param, item) {
                        var sumRect = param[1];
                        var match = (viewPortRectangle[/* top */0] + viewPortRectangle[/* height */1] | 0) <= sumRect[/* top */0];
                        if (match) {
                          return /* tuple */[
                                  param[0],
                                  sumRect
                                ];
                        } else {
                          return item;
                        }
                      }));
                Curry._1(setIndex, (function (_prev) {
                        var init = previousSnapshot.current;
                        previousSnapshot.current = /* record */[
                          /* startIndex */_prev[/* startIndex */0],
                          /* endIndex */init[/* endIndex */1]
                        ];
                        var init$1 = previousSnapshot.current;
                        previousSnapshot.current = /* record */[
                          /* startIndex */init$1[/* startIndex */0],
                          /* endIndex */_prev[/* endIndex */1]
                        ];
                        prevViewPortRec.current = viewPortRec.current;
                        viewPortRec.current = /* record */[
                          /* top */element$1.scrollTop | 0,
                          /* height */element$1.clientHeight
                        ];
                        var eid = endItem[0];
                        var sid = startItem[0];
                        var match = (sid - bufferCount | 0) < 1;
                        var match$1 = (eid + bufferCount | 0) > data.length;
                        return /* record */[
                                /* startIndex */match ? 1 : sid - bufferCount | 0,
                                /* endIndex */match$1 ? data.length : eid + bufferCount | 0
                              ];
                      }));
              }
              Curry._1(setCorrection, (function (x) {
                      return x + 1 | 0;
                    }));
              return /* () */0;
            })), (function (prim) {
          requestAnimationFrame(prim);
          return /* () */0;
        }));
  React.useEffect((function () {
          var match = Belt_Option.map(Caml_option.nullable_to_opt(viewPortRef.current), (function (prim) {
                  return prim;
                }));
          if (match !== undefined) {
            Caml_option.valFromOption(match).addEventListener("scroll", handleScroll);
          }
          return (function (param) {
                    var match = Belt_Option.map(Caml_option.nullable_to_opt(viewPortRef.current), (function (prim) {
                            return prim;
                          }));
                    if (match !== undefined) {
                      Caml_option.valFromOption(match).removeEventListener("scroll", handleScroll);
                      return /* () */0;
                    } else {
                      return /* () */0;
                    }
                  });
        }), /* array */[element]);
  React.useEffect((function () {
          return (function (param) {
                    return Curry._2(onDestroy, viewPortRec.current[/* top */0], heightMap.current);
                  });
        }), /* array */[]);
  React.useEffect((function () {
          var prevRec = Belt_HashMapInt.copy(recMap.current);
          Belt_HashMapInt.forEach(refMap.current, (function (key, elementRef) {
                  return calculateHeight(elementRef, heightMap, key, margin);
                }));
          var recs = createNewRecs(heightMap, identity, defaultHeight, data);
          recMap.current = recs;
          var findAnchor = function (param) {
            var prev = previousSnapshot.current;
            var both = Belt_Array.keep(data, (function (item) {
                    var id = Curry._1(identity, item);
                    var match = prev[/* startIndex */0] <= id && prev[/* endIndex */1] >= id && startIndex <= id && endIndex >= id;
                    if (match) {
                      return true;
                    } else {
                      return false;
                    }
                  }));
            var partial_arg = prevViewPortRec.current;
            var interSectWithPrevViewPortPosition = function (param) {
              return doesIntersectWith(partial_arg, param);
            };
            var anchor = Belt_Array.reduce(Belt_Array.map(both, (function (item) {
                        return Belt_Option.mapWithDefault(Belt_HashMapInt.get(prevRec, Curry._1(identity, item)), /* tuple */[
                                    Curry._1(identity, item),
                                    /* record */[
                                      /* top */0,
                                      /* height */0
                                    ]
                                  ], (function (rectangle) {
                                      return /* tuple */[
                                              Curry._1(identity, item),
                                              rectangle
                                            ];
                                    }));
                      })), /* tuple */[
                  0,
                  /* record */[
                    /* top */0,
                    /* height */0
                  ]
                ], (function (best, current) {
                    var match = Curry._1(interSectWithPrevViewPortPosition, current[1]) && !Curry._1(interSectWithPrevViewPortPosition, best[1]);
                    if (match) {
                      return current;
                    } else {
                      return best;
                    }
                  }));
            var currentAnchorRectangle = Belt_Option.mapWithDefault(Belt_HashMapInt.get(recs, anchor[0]), /* record */[
                  /* top */0,
                  /* height */0
                ], (function (x) {
                    return x;
                  }));
            var correction = currentAnchorRectangle[/* top */0] - anchor[1][/* top */0] | 0;
            var match = correction > 0;
            if (element !== undefined && match) {
              Caml_option.valFromOption(element).scrollBy({
                    top: correction,
                    left: 0.0,
                    behavior: "auto"
                  });
              return /* () */0;
            } else {
              return /* () */0;
            }
          };
          var match = heightDelta(data, identity, recs, prevRec) === 0;
          if (!match) {
            findAnchor(/* () */0);
          }
          return undefined;
        }), /* array */[
        startIndex,
        endIndex
      ]);
  React.useEffect((function () {
          rawHandler(Belt_Option.map(Caml_option.nullable_to_opt(viewPortRef.current), (function (prim) {
                      return prim;
                    })));
          return undefined;
        }), /* array */[]);
  var startPadding = Belt_Option.mapWithDefault(Belt_HashMapInt.get(recMap.current, startIndex), 0, (function (x) {
          return x[/* top */0];
        }));
  var endValue = Belt_Option.mapWithDefault(Belt_HashMapInt.get(recMap.current, endIndex), 0, (function (x) {
          return x[/* top */0];
        }));
  var lastValue = Belt_Option.mapWithDefault(Belt_HashMapInt.get(recMap.current, Belt_HashMapInt.size(recMap.current)), 0, (function (x) {
          return x[/* top */0];
        }));
  var endPadding = lastValue - endValue | 0;
  var match$7 = !refreshing;
  if (match$7) {
    return React.createElement(List$ReactHooksTemplate.make, {
                afterPadding: endPadding,
                beforePadding: startPadding,
                data: Belt_Array.keep(data, (function (item) {
                        if (Curry._1(identity, item) <= endIndex) {
                          return Curry._1(identity, item) >= startIndex;
                        } else {
                          return false;
                        }
                      })),
                identity: identity,
                onRefChange: (function (id, elementRef) {
                    return Belt_HashMapInt.set(refMap.current, id, elementRef);
                  }),
                renderItem: renderItem,
                onReady: (function (param) {
                    var setScrollTop = Belt_Option.map(Belt_Option.map(Caml_option.nullable_to_opt(viewPortRef.current), (function (prim) {
                                return prim;
                              })), (function (prim, prim$1) {
                            prim.scrollTop = prim$1;
                            return /* () */0;
                          }));
                    var recs = createNewRecs(heightMap, identity, defaultHeight, data);
                    recMap.current = recs;
                    if (setScrollTop !== undefined) {
                      Curry._1(setScrollTop, Belt_Option.mapWithDefault(defaultPosition, 0, (function (prim) {
                                  return prim;
                                })));
                      var match = Belt_Option.map(Caml_option.nullable_to_opt(viewPortRef.current), (function (prim) {
                              return prim;
                            }));
                      if (match !== undefined) {
                        viewPortRec.current = /* record */[
                          /* top */Belt_Option.mapWithDefault(defaultPosition, 0, (function (x) {
                                  return x;
                                })),
                          /* height */Caml_option.valFromOption(match).clientHeight
                        ];
                      }
                      return rawHandler(Belt_Option.map(Caml_option.nullable_to_opt(viewPortRef.current), (function (prim) {
                                        return prim;
                                      })));
                    } else {
                      return /* () */0;
                    }
                  })
              });
  } else {
    return refreshingComponent;
  }
}

var make = VirtualizedList;

exports.add = add;
exports.recsHeight = recsHeight;
exports.heightDelta = heightDelta;
exports.calculateHeight = calculateHeight;
exports.scheduler = scheduler;
exports.scrollTop = scrollTop;
exports.log = log;
exports.throttle = throttle;
exports.sortByKey = sortByKey;
exports.defaultPositionValue = defaultPositionValue;
exports.isBetween = isBetween;
exports.doesIntersectWith = doesIntersectWith;
exports.createNewRecs = createNewRecs;
exports.make = make;
/* defaultPositionValue Not a pure module */
